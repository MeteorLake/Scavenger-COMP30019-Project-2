using System.Collections;
using System.Collections.Generic;

using UnityEngine;

class LTree {
    public List<LTree> branches;
    
    public Vector3 start;
    public Vector3 end;

    public LTree(Vector3 start, Vector3 end, List<LTree> branches) {
        this.start = start;
        this.end = end;

        this.branches = branches;
    }

    // Marks out an LTree that gets generated by the game
    public void MarkLTree(float scale) {
        // Gets the midpoint between the start and end and the length of the branch
        Vector3 midpoint = (end + start) / 2.0f;
        float length = (end - start).magnitude;

        // Calculates the rotation
        Quaternion rot = Quaternion.LookRotation(end - start, new Vector3(0.0f, 1.0f, 0.0f));

        // Creates a cube from the branch
        GameObject cube = GameObject.CreatePrimitive(PrimitiveType.Cube);
        cube.transform.position = midpoint;
        cube.transform.localScale = new Vector3(scale, scale, length);
        cube.transform.rotation *= rot;

        // Loops over the child branches
        foreach (LTree subBranch in branches) {
            subBranch.MarkLTree(scale);
        }
    }

    //---------------------------
    Vector3 ProjectPointLine(Vector3 point, Vector3 lineStart, Vector3 lineEnd) {
        Vector3 relativePoint = point - lineStart;
        Vector3 lineDirection = lineEnd - lineStart;
        float length = lineDirection.magnitude;
        Vector3 normalizedLineDirection = lineDirection;
        if (length > .000001f)
            normalizedLineDirection /= length;

        float dot = Vector3.Dot(normalizedLineDirection, relativePoint);
        dot = Mathf.Clamp(dot, 0.0F, length);

        return lineStart + normalizedLineDirection * dot;
    }

    // Calculates the distance from the tree to the given point
    public float DistanceToTree(Vector3 point) {
        // Calculates the distance between the point and the line segment
        // formed by the start and end
        float distance = Vector3.Magnitude(ProjectPointLine(point, start, end) - point);

        // Loops over each branch, calculates the distance
        foreach (LTree subBranch in branches) {
            distance = Mathf.Min(distance, subBranch.DistanceToTree(point));
        }

        return distance;
    }
    
    //---------------------------

    public void GetTreeDistanceListHelper(ref List<float> distanceList, Vector3 point, float distance) {
        // Calculates the distance between the point and the line segment
        // formed by the start and end
        float pointDistance = Vector3.Magnitude(ProjectPointLine(point, start, end) - point);

        if (pointDistance <= distance)
            distanceList.Add(pointDistance);

        // Loops over the branches
        foreach (LTree subBranch in branches) {
            subBranch.GetTreeDistanceListHelper(ref distanceList, point, distance);
        }
    }

    // Given a point and a distance to the tree, returns a list of distances that the
    // point is from the tree.
    public List<float> GetTreeDistanceList(Vector3 point, float distance) {
        // Initialises the list of tree distances
        List<float> distanceList = new List<float>();

        // Using the helper function, loops over the branches
        this.GetTreeDistanceListHelper(ref distanceList, point, distance);

        return distanceList;

    }

    //---------------------------

    // Gets the bounds of the LTree
    public Bounds GetTreeBounds() {
        // Creates a bounding volume
        Bounds treeBounds = new Bounds();

        // Encapsulates the start and end of the 
        EncapsulateBranchBounds(ref treeBounds);

        return treeBounds;
    }

    public void EncapsulateBranchBounds(ref Bounds treeBounds) {
        // Adds the start and end to the bounds, adds for each branch
        treeBounds.Encapsulate(start);
        treeBounds.Encapsulate(end);

        // Loops over each branch, encaps branches
        foreach (LTree subBranch in branches) {
            subBranch.EncapsulateBranchBounds(ref treeBounds);
        }
    }
}

public class ProceduralTerrain : MonoBehaviour
{

    [Header("Distances")]
    public uint inRiverMinDistance = 0;
    public uint inRiverMaxDistance = 5;
    public uint nearRiverMinDistance = 15;
    public uint nearRiverMaxDistance = 45;
    public uint campMinDistance = 45;
    public uint campMaxDistance = 70;
    public uint farRiverMinDistance = 160;
    public uint farRiverMaxDistance = 1024;

    [Header("NumCentralObjects")]
    public uint inRiverNumCentralObjects = 10;
    public uint nearRiverNumCentralObjects = 140;
    public uint campNumCentralObjects = 5;
    public uint farRiverHumanNumCentralObjects = 15;
    public uint farRiverNatureNumCentralObjects = 60;
    public uint beachHumanNumCentralObjects = 5;
    public uint beachNatureNumCentralObjects = 20;
    
    [Header("NumTreasure")]
    public uint nearRiverNumTreasure = 40;
    public uint campNumProps = 4;
    public uint campNumTreasure = 60;

    public uint farRiverHumanNumTreasure = 80;
    public uint farRiverNatureNumTreasure = 60;
    public uint farRiverNumOxygenTanks = 60;

    public uint beachHumanNumTreasure = 60;
    public uint beachNatureNumTreasure = 40;
    public uint beachNumOxygenTanks = 60;

    [Header("Radii (spawn treasures within x of central objects)")]
    public float spawnMinRadius = 5.0f;
    public float spawnMaxRadius = 15.0f;
    
    [Header("Central Object Prefab Paths")]
    public string[] inRiver;
    public string[] nearRiver;
    public string[] camps;
    public string[] campSurrounds;
    public string[] farRiverHuman;
    public string[] farRiverNature;
    public string[] beachHuman;
    public string[] beachNature;

    //---------------------------

    [Header("Treasure Prefab Paths")]
    public string[] nearRiverTreasure;
    public string[] campTreasure;
    public string[] farRiverHumanTreasure;
    public string[] farRiverNatureTreasure;
    public string[] beachHumanTreasure;
    public string[] beachNatureTreasure;
    public string[] oxygenTanks;
    
    //---------------------------

    [Header("Player Settings")]
    public string spaceship;

    public string[] oxygenSupply;
    
    //---------------------------

    public GameObject player;
    
    //---------------------------

    [Header("Terrain Settings")]
    public float edgeDistance = 50.0f;
    public float edgeFalloff = 30.0f;

    public Vector3 terrainDimensions = new Vector3(1024.0f, 64.0f, 1024.0f);
    public Vector3 terrainPosition = new Vector3(0, 2.0f, 4.0f);

    public int fullGrassPatchCapacity = 32;

    //---------------------------
    
    [Header("Other Settings")]
    public float casualTargetModifier = 0.15f;
    public float standardTargetModifier = 0.3f;
    public float hardcoreTargetModifier = 0.75f;

    //---------------------------

    GameObject terrain;
    LTree river;

    // Tracks the total number of credits spread throughout the game.
    uint totalCredits;

    // Tracks whether or not the terrain has fully loaded
    bool terrainLoaded = false;

    // Keeps track of the starting oxygen station + the camps
    GameObject startingOxygenObject;
    List<GameObject> campOxygenStations = new List<GameObject>();
    
    //---------------------------

    // Grid for checking bounding positions so that no objects overlap with one-another.
    Dictionary<(int, int), List<Bounds>> boundingGrid = new Dictionary<(int, int), List<Bounds>>();

    // Stores the distance between each bounding grid square
    const int BOUNDING_GRID_DIMENSIONS = 64;

    //---------------------------

    // Start is called before the first frame update
    void Start()
    {
        StartCoroutine(LoadAllTerrain());
    }

    IEnumerator LoadAllTerrain() {
        // Generates terrain
        terrain = GenerateTerrain(
            terrainDimensions,
            new Vector3(0, 2.0f, 4.0f),
            0.07f, 0.2f, 32.0f, 512
        );

        // Gets the bounds of the terrain
        TerrainData terrainData = terrain.GetComponent<Terrain>().terrainData;
        Bounds terrainBounds = terrainData.bounds;

        // Gets one of the corners for the terrain at random
        Vector3 terrainCorner = terrainData.bounds.center + new Vector3(
            (float) (Random.Range(0, 2) * 2 - 1) * terrainBounds.extents.x,
            0.0f,
            (float) (Random.Range(0, 2) * 2 - 1) * terrainBounds.extents.z
        );

        //------------------------------------

        // Points the river towards the center of the map from the corner
        Vector3 riverDirection = (terrainBounds.center - terrainCorner).normalized;

        // Generates the LTree
        river = GenerateBoundedLTree(
            8, riverDirection, terrainCorner, 250.0f,
            terrainCorner, riverDirection, 40.0f,
            55.0f
        );
        
        // Displaces the vertices of the terrain with the LTree
        yield return DisplaceLTree(river, 15.0f, -0.07f, 120.0f, 170.0f);
        
        // Generates cliffs
        GenerateEdges();

        //------------------------------------

        // Generates the spaceship
        GameObject spaceshipObject = GenerateSpaceship(30.0f, 140.0f, 0.0f, 512.0f);

        // Sets the player object for the spaceship
        Spaceship spaceship = spaceshipObject.GetComponentInChildren<Spaceship>();
        spaceship.player = player;

        // Generates the oxygen supply around the spaceship
        List<GameObject> singleSpaceship = new List<GameObject>();
        singleSpaceship.Add(spaceshipObject);

        // Creates the starting oxygen station, sets the value for this station
        List<GameObject> startingStation = GenerateItemsRadius(
            oxygenSupply, ref singleSpaceship, 1,
            3.0f, 15.0f, 10.0f,
            true, false, false, true
        );
        startingOxygenObject = startingStation[0];

        // Move the player around the spaceship
        MovePlayerAroundSpaceship(ref spaceshipObject, 20.0f, 5.0f);

        //------------------------------------

        // Generates the props at various distances from the river
        List<GameObject> inRiverProps = GenerateItems(
            inRiver, inRiverNumCentralObjects, inRiverMinDistance, inRiverMaxDistance,
            false, true, false, false
        );
        List<GameObject> nearRiverProps = GenerateItems(
            nearRiver, nearRiverNumCentralObjects, nearRiverMinDistance, nearRiverMaxDistance,
            false, true, false, false
        );
        
        List<GameObject> farRiverNatureProps = GenerateItems(
            farRiverNature, farRiverNatureNumCentralObjects, farRiverMinDistance, farRiverMaxDistance,
            false, false, false, false
        );
        List<GameObject> farRiverHumanProps = GenerateItems(
            farRiverHuman, farRiverHumanNumCentralObjects, farRiverMinDistance, farRiverMaxDistance,
            false, true, false, false
        );

        List<GameObject> beachHumanProps = GenerateEdgeItems(
            beachHuman, beachHumanNumCentralObjects,
            false, true, false
        );
        List<GameObject> beachNatureProps = GenerateEdgeItems(
            beachNature, beachNatureNumCentralObjects,
            false, false, false
        );

        // Generates the camp props, add to a large "CampProps" list
        List<GameObject> campProps = new List<GameObject>();

        for (int i = 0; i < campNumCentralObjects; i++) {
            // Generates the camp clutter + center
            List<GameObject> campCenterProps = GenerateItems(
                camps, 1, campMinDistance, campMaxDistance,
                true, false, false, true
            );
            List<GameObject> campSurroundProps = GenerateItemsRadius(
                campSurrounds, ref campCenterProps, campNumProps,
                spawnMinRadius, spawnMaxRadius, 30.0f,
                true, false, false, true
            );

            // Generates the camp treasures
            GenerateItemsRadius(
                campTreasure, ref campSurroundProps, campNumTreasure / campNumCentralObjects, spawnMinRadius, spawnMaxRadius, 30.0f,
                false, false, false, true
            );

            // Gets the main camp center object, check the length just in case
            if (campCenterProps.Count > 0) {
                GameObject campCenter = campCenterProps[0];

                // Inside the campCenter, finds an oxygen station and adds it to the oxygen stations
                GameObject oxygenStation = campCenter.transform.Find("OxygenStation").gameObject;
                campOxygenStations.Add(oxygenStation);
            }
        }

        //------------------------------------

        // Generates the near/far from river treasures
        GenerateItemsRadius(
            nearRiverTreasure, ref nearRiverProps, nearRiverNumTreasure, spawnMinRadius, spawnMaxRadius, 30.0f,
            false, true, false, false
        );

        // Generates the far from river treasure + oxygen tanks
        GenerateItemsRadius(
            farRiverHumanTreasure, ref farRiverHumanProps, farRiverHumanNumTreasure, spawnMinRadius, spawnMaxRadius, 30.0f,
            true, false, false, false
        );
        GenerateItemsRadius(
            farRiverNatureTreasure, ref farRiverNatureProps, farRiverNatureNumTreasure, spawnMinRadius, spawnMaxRadius, 30.0f,
            true, false, false, false
        );
        GenerateItemsRadius(
            oxygenTanks, ref farRiverHumanProps, farRiverNumOxygenTanks, spawnMinRadius, spawnMaxRadius, 30.0f,
            true, false, true, false
        );

        // Generates the beach treasure + oxygen tanks
        GenerateItemsRadius(
            beachHumanTreasure, ref beachHumanProps, beachHumanNumTreasure, spawnMinRadius, spawnMaxRadius, 30.0f,
            true, false, true, false
        );
        GenerateItemsRadius(
            beachNatureTreasure, ref beachNatureProps, beachNatureNumTreasure, spawnMinRadius, spawnMaxRadius, 30.0f,
            true, false, true, false
        );
        GenerateItemsRadius(
            oxygenTanks, ref beachHumanProps, beachNumOxygenTanks, spawnMinRadius, spawnMaxRadius, 30.0f,
            true, false, true, false
        );

        // Dries the grass around the farRiver props
        foreach (GameObject prop in farRiverHumanProps) {
            DryGrass(prop);
            yield return null;
        }

        foreach (GameObject prop in farRiverNatureProps) {
            DryGrass(prop);
            yield return null;
        }
        
        //------------------------------------

        // Get the player object, set the player credit target, and begins oxygen depletion
        PlayerController playerController = player.GetComponent<PlayerController>();
        playerController.SetOxygenDepleting(true);
        playerController.SetPaused(false);
        playerController.playerLoaded = true;

        // Sets the credit target based on the difficulty level
        string difficultyLevel = PlayerPrefs.GetString("Difficulty");

        if (difficultyLevel == "CASUAL")
            playerController.creditTarget = (uint) (totalCredits * casualTargetModifier);
        else if (difficultyLevel == "STANDARD")
            playerController.creditTarget = (uint) (totalCredits * standardTargetModifier);
        else if (difficultyLevel == "HARDCORE")
            playerController.creditTarget = (uint) (totalCredits * hardcoreTargetModifier);

        //------------------------------------

        terrainLoaded = true;
    }

    //---------------------------

    // Generates basic terrain based on an input (Temporary)
    GameObject GenerateTerrain(
        Vector3 dimensions, Vector3 center, float defaultHeight,
        float noiseVariance, float noiseScale, int resolution
    ) {
        // Create a new, empty GameObject
        GameObject terrain = new GameObject("Terrain");
        terrain.transform.position = center;
        
        // Creates the TerrainData
        TerrainData terrainData = Resources.Load<TerrainData>("Other/TerrainDataBase");
        terrainData.size = dimensions;
        terrainData.heightmapResolution = resolution;
        terrainData.baseMapResolution = resolution;
        terrainData.SetDetailResolution(resolution, 32);

        // Sets the grass settings
        terrainData.wavingGrassStrength = 0.1f;
        terrainData.wavingGrassSpeed = 1.0f;

        //---------------------------
        
        // Creates the terrain layers
        TerrainLayer grass = new TerrainLayer();
        grass.diffuseTexture = Resources.Load<Texture2D>("Textures/Grass_Diffuse");
        grass.normalMapTexture = Resources.Load<Texture2D>("Textures/Grass_Normal");
        grass.tileSize = new Vector2(5.0f, 5.0f);

        TerrainLayer dirt = new TerrainLayer();
        dirt.diffuseTexture = Resources.Load<Texture2D>("Textures/Dirt_Diffuse");
        dirt.tileSize = new Vector2(5.0f, 5.0f);
        
        TerrainLayer sand = new TerrainLayer();
        sand.diffuseTexture = Resources.Load<Texture2D>("Textures/Sand_Diffuse");
        sand.normalMapTexture = Resources.Load<Texture2D>("Textures/Sand_Normal");
        sand.tileSize = new Vector2(10.0f, 10.0f);

        TerrainLayer dryGround = new TerrainLayer();
        dryGround.diffuseTexture = Resources.Load<Texture2D>("Textures/Dry_Ground_Diffuse");
        dryGround.tileSize = new Vector2(5.0f, 5.0f);

        // Inits a splatPrototypes array, sets the first value
        TerrainLayer[] terrainLayers = new TerrainLayer[4];
        terrainLayers[0] = grass;
        terrainLayers[1] = dirt;
        terrainLayers[2] = sand;
        terrainLayers[3] = dryGround;

        // Creates the detail prototypes
        DetailPrototype grassDetail = new DetailPrototype();
        grassDetail.prototypeTexture = Resources.Load<Texture2D>("Textures/Grass_Detail");
        grassDetail.healthyColor = new Color(1.0f, 1.0f, 1.0f, 1.0f);
        grassDetail.dryColor = new Color(1.0f, 1.0f, 1.0f, 1.0f);
        grassDetail.minWidth = 1.0f;
        grassDetail.maxWidth = 1.5f;
        grassDetail.maxHeight = 1.5f;

        DetailPrototype dryGrassDetail = new DetailPrototype();
        dryGrassDetail.prototypeTexture = Resources.Load<Texture2D>("Textures/Dry_Grass_Detail");
        dryGrassDetail.healthyColor = new Color(1.0f, 1.0f, 1.0f, 1.0f);
        dryGrassDetail.dryColor = new Color(1.0f, 1.0f, 1.0f, 1.0f);
        dryGrassDetail.minWidth = 1.0f;
        dryGrassDetail.maxWidth = 1.5f;
        dryGrassDetail.maxHeight = 1.5f;
        
        // Inits a detailPrototypes array, sets the first value
        DetailPrototype[] detailPrototypes = new DetailPrototype[2];
        detailPrototypes[0] = grassDetail;
        detailPrototypes[1] = dryGrassDetail;

        // Sets the prototype arrays
        terrainData.terrainLayers = terrainLayers;
        terrainData.detailPrototypes = detailPrototypes;
            
        //---------------------------

        // Gets the terrainData height, alpha + detail map
        float[,] heights = terrainData.GetHeights(0, 0, resolution, resolution);
        int[,] detailMap = terrainData.GetDetailLayer(0, 0, resolution, resolution, 0);
        float[,,] alphaMap = terrainData.GetAlphamaps(0, 0, resolution, resolution);

        // Loops over the heights, sets new heights
        for (int x = 0; x < resolution; x++) {
            for (int y = 0; y < resolution; y++) {
                float mapNoise = Mathf.PerlinNoise((float) x / noiseScale, (float) y / noiseScale) * noiseVariance;
                heights[y, x] = defaultHeight + mapNoise;
                detailMap[y, x] = fullGrassPatchCapacity;

                alphaMap[y, x, 0] = 1.0f;
                alphaMap[y, x, 1] = 0.0f;
                alphaMap[y, x, 2] = 0.0f;
                alphaMap[y, x, 3] = 0.0f;
            }
        }

        // Sets the heights
        terrainData.SetHeights(0, 0, heights);
        terrainData.SetDetailLayer(0, 0, 0, detailMap);
        terrainData.SetAlphamaps(0, 0, alphaMap);

        // Adds the TerrainCollider + Terrain
        TerrainCollider terrainCollider = terrain.AddComponent<TerrainCollider>();
        Terrain terrainComponent = terrain.AddComponent<Terrain>();

        // Before completion, set the grass draw distance
        terrainComponent.detailObjectDistance = 180;

        // Sets a material
        terrainComponent.materialTemplate = Resources.Load<Material>("Materials/Terrain_Tex");

        // Sets the terrainData
        terrainComponent.terrainData = terrainData;
        terrainCollider.terrainData = terrainData;

        return terrain;
    }

    //---------------------------

    // Generates a river L-Tree with a particular count
    LTree GenerateLTree(uint count, Vector3 direction, Vector3 start, float length) {
        // End the recursion if the count is 0
        if (count <= 0)
            return null;

        // From the start, gets the end vector based on the direction
        Vector3 end = start + direction.normalized * length;

        // Now that we have the end, we can generate sub l-trees that go in random directions
        List<LTree> branches = new List<LTree>();

        // Loop over a random number of branches to add
        for (int i = 0; i < (int) Mathf.Floor(Random.Range(1.0f, 3.0f)); i++) {
            // Generates the new branch
            LTree newTree = GenerateLTree(
                    count - 1,
                    Quaternion.Euler(0, Random.Range(-55.0f, 55.0f), 0) * direction,
                    end, length * 0.9f
                );

            // Adds a branch
            if (newTree != null)
                branches.Add(newTree);
        }

        return new LTree(start, end, branches);
    }

    // Generates a river L-Tree bounded by a particular origin direction and angle
    LTree GenerateBoundedLTree(
        uint count, Vector3 direction, Vector3 start, float length,
        Vector3 origin, Vector3 originalDirection, float boundingAngle,
        float spreadAngle
    ) {
        // End the recursion if the count is 0
        if (count <= 0)
            return null;

        // Initialise a final "end" vector and a boolean to indicate if it's been set
        Vector3 end = new Vector3(0.0f, 0.0f, 0.0f);
        bool endInitialised = false;

        while (!endInitialised) {
            // First, we get the current direction of the tree multiplied by a random angle. This random angle
            // will be the bounding angle
            Vector3 randomisedDirection = Quaternion.Euler(0, Random.Range(-spreadAngle, spreadAngle), 0) * direction;

            // From the start, gets the end vector based on the direction
            Vector3 candidateEnd = start + randomisedDirection.normalized * length;

            // From the candidate end, get a vector that goes from the origin, normalize
            Vector3 candidateEndDirection = (candidateEnd - origin).normalized;

            // We can then find the dot product between the original direction and find the
            // inverse cosine of this resultant number to get the angle
            float candidateEndAngle = Mathf.Acos(Vector3.Dot(
                originalDirection.normalized,
                candidateEndDirection
            ));

            // If the candidate angle is between the bounding angles, then set the end
            if (candidateEndAngle < boundingAngle && candidateEndAngle > -boundingAngle) {
                end = candidateEnd;
                endInitialised = true;
            }
        }

        // Now that we have the end, we can generate sub l-trees that go in random directions
        List<LTree> branches = new List<LTree>();

        // Loop over a random number of branches to add
        for (int i = 0; i < (int) Mathf.Floor(Random.Range(1.3f, 3.0f)); i++) {
            // We're going to generate two lines where 
            
            // Generates the new branch
            LTree newTree = GenerateBoundedLTree(
                    count - 1, direction, end, length * 0.9f,
                    origin, originalDirection, boundingAngle,
                    spreadAngle
                );

            // Adds a branch
            if (newTree != null)
                branches.Add(newTree);
        }

        return new LTree(start, end, branches);
    }

    //---------------------------

    // Generates edges based on a distance from the corners, height, and other factors such
    // as displacement
    void GenerateEdges() {
        // First, we want to get the terrain component + data
        Terrain terrainComponent = terrain.GetComponent<Terrain>();
        TerrainData terrainData = terrainComponent.terrainData;
        
        // Get the terrain height + width
        int terrainHeight = terrainData.heightmapTexture.height - 1;
        int terrainWidth = terrainData.heightmapTexture.width - 1;

        // Gets the height data + alpha maps
        float[,] heights = terrainData.GetHeights(0, 0, terrainWidth, terrainHeight);
        float[,,] alphaMaps = terrainData.GetAlphamaps(0, 0, terrainWidth, terrainHeight);
        int[,] wetDetailMap = terrainData.GetDetailLayer(0, 0, terrainWidth, terrainHeight, 0);

        // Loop over the terrain heights
        for (int x = 0; x < terrainWidth; x++) {
            for (int y = 0; y < terrainHeight; y++) {
                // First, we want to check if the terrain is even in the range
                // we are concerned with
                if (
                    (x < edgeDistance) ||
                    (x > terrainWidth - (edgeDistance)) ||
                    (y < edgeDistance) ||
                    (y > terrainWidth - (edgeDistance))
                ) {
                    // Calculates the distance from the edge this height is on the x and y axes
                    float xDistance = Mathf.Clamp(
                        (terrainWidth / 2.0f) - Mathf.Abs(x - (terrainWidth / 2.0f)),
                        0.0f, edgeFalloff
                    ) / edgeFalloff;
                    
                    float yDistance = Mathf.Clamp(
                        (terrainHeight / 2.0f) - Mathf.Abs(y - (terrainHeight / 2.0f)),
                        0.0f, edgeFalloff
                    ) / edgeFalloff;
                        
                    // Calculates the "total" distance
                    float totalDistance = xDistance * yDistance;

                    // Then, calculate the displacement based on the the "aggregate" distance
                    float terrainDisplacement = Mathf.Clamp(
                        -(Mathf.Cos(Mathf.PI * totalDistance) - 1.0f) / 2.0f,
                        0.0f, 1.0f
                    );

                    //---------------------------

                    // Sets the height based on the terrain displacement
                    heights[x, y] = heights[x, y] * terrainDisplacement;

                    // Calculates the "fade" of the sand
                    float sandFade = Mathf.Pow(terrainDisplacement, 1.8f);

                    // Sets the alphaMaps for this terrain
                    alphaMaps[x, y, 0] = alphaMaps[x, y, 0] * sandFade;
                    alphaMaps[x, y, 1] = alphaMaps[x, y, 1] * sandFade;
                    alphaMaps[x, y, 2] = 1.0f - sandFade;

                    // Calculates how much the grass fades by
                    float grassFade = Mathf.Clamp((sandFade - 0.3f) / 0.7f, 0.0f, 1.0f);

                    // Sets the detail map for the grass
                    wetDetailMap[x, y] = (int) (grassFade * wetDetailMap[x, y]);
                }
            }
        }

        // Set the maps, flush the data
        terrainData.SetHeights(0, 0, heights);
        terrainData.SetAlphamaps(0, 0, alphaMaps);
        terrainData.SetDetailLayer(0, 0, 0, wetDetailMap);

        terrainComponent.Flush();
    }
    
    //---------------------------

    // Test
    List<Bounds> boundTestList = new List<Bounds>();

    void OnDrawGizmos() {
        foreach (Bounds bound in boundTestList) {
            Gizmos.color = new Color(1.0f, 1.0f, 0.0f);
            Gizmos.DrawWireCube(bound.center, bound.size);
        }
    }

    // From a particular gameobject, gets the world bounds of all of its children.
    // In order to address problemx with there
    Bounds GetObjectBounds(GameObject target) {
        // Inits the largest extant for the ref object
        Bounds bounds = new Bounds(target.transform.position, new Vector3(0.0f, 0.0f, 0.0f));
        
        // Gets the colliders inside the GameObject
        Renderer[] renderers = target.GetComponentsInChildren<Renderer>();

        // For each, collider, encapsulate in the main bounds so that we can later get
        // the extants
        foreach (Renderer renderer in renderers)
            bounds.Encapsulate(renderer.bounds);

        boundTestList.Add(bounds);

        return bounds;
    }

    (int, int) GetBoundingGridPos(Vector3 position) {
        return (
            (int) Mathf.Floor(position.x / BOUNDING_GRID_DIMENSIONS),
            (int) Mathf.Floor(position.z / BOUNDING_GRID_DIMENSIONS)
        );
    }

    // Adds an object to the bounding dictionary
    void AddToBoundingGrid(Bounds bounds) {
        // Gets the center of the bounds, but modified to fit on the bounding grid
        (int, int) boundingGridPos = GetBoundingGridPos(bounds.center);

        // If the bounding grid position doesn't exist yet in the dictionary, add it
        if (!boundingGrid.ContainsKey(boundingGridPos)) {
            boundingGrid[boundingGridPos] = new List<Bounds>();
        }

        // Adds to the list of bounds within this square
        boundingGrid[boundingGridPos].Add(bounds);
    }

    // Checks adjacent bounds to see if the object collides with anything
    bool ObjectIntersects(Bounds bounds) {
        // Initialises the boolean that determines if there's a collision
        bool doesIntersect = false;

        // Gets the center of the bounds, but modified to fit on the bounding grid
        (int, int) boundingGridPos = GetBoundingGridPos(bounds.center);

        // Loops over the adjacent bounds to check for collisions
        for (int x = 0; x < 3; x++) {
            for (int y = 0; y < 3; y++) {
                // Calculates the current bounding pos that's being examined
                (int, int) currentPos = (boundingGridPos.Item1 + x - 1, boundingGridPos.Item2 + y - 1);

                // If that list isn't null, then loop over the list
                if (boundingGrid.ContainsKey(currentPos)) {
                    // Loop over the items in this list, determine if there's an intersection
                    foreach (Bounds checkedBound in boundingGrid[currentPos]) {
                        doesIntersect = doesIntersect || (checkedBound.Intersects(bounds));
                    }
                }
            }
        }

        return doesIntersect;
    }
    
    //---------------------------

    // Instantiates a specified prefab at a particular position. Accounts for raycasting to
    // the ground to deal with proper placement + alignment.
    GameObject InstantiateGameobject(
        string prefabName, Vector3 targetPosition, bool rotateToTerrain,
        bool removeGrass, bool flattenTerrain
    ) {
        // Create a ray down to the terrain
        Ray positionalRay = new Ray(
            targetPosition + new Vector3(0.0f, 150.0f, 0.0f),
            new Vector3(0.0f, -1.0f, 0.0f)
        );
        RaycastHit hitInfo;

        // Check if the ray hit anything. If it did, then set that position
        if (Physics.Raycast(positionalRay, out hitInfo, 250.0f)) {
            // Instantiates the prefab
            GameObject item = Instantiate(Resources.Load<GameObject>("Prefabs/" + prefabName));

            // Set the position based on the hit
            item.transform.position = hitInfo.point;

            // Gets a rotation based on the hit tangent
            Vector3 hitNormal = hitInfo.normal;
            Quaternion normalRot = Quaternion.FromToRotation(new Vector3(0.0f, 1.0f, 0.0f), hitNormal);

            // Sets a random rotation for this prop
            if (rotateToTerrain)
                item.transform.rotation = normalRot * Quaternion.Euler(0.0f, Random.Range(0.0f, 360.0f), 0.0f);
            else
                item.transform.rotation = Quaternion.Euler(0.0f, Random.Range(0.0f, 360.0f), 0.0f);

            // Obtains the object's bounds
            Bounds bounds = GetObjectBounds(item);

            // First, we want to check if the object has any intersections
            if (!ObjectIntersects(bounds)) {
                // Clears the grass if it needs to be removed.
                if (removeGrass)
                    ClearGrass(item);

                // Flattens terrain if need be
                if (flattenTerrain)
                    FlattenTerrain(item, hitInfo.point.y);

                // Adds to the credit total
                AddPickupValue(item);

                // Adds the bounds to the bounds grid
                AddToBoundingGrid(bounds);

                // Returns the gameobject that was just created
                return item;
            }
            else {
                // Destroys the item, returns null
                Destroy(item);
                return null;
            }
        }
        else {
            return null;
        }
    }
    
    //---------------------------

    // Generates the spaceship
    GameObject GenerateSpaceship(float riverDistance, float maxRiverDistance, float minDistance, float maxDistance) {
        // Initialises the spaceship gameobject
        GameObject finalSpaceship = null;

        // Gets the terrain component + terrainData
        Terrain terrainComponent = terrain.GetComponent<Terrain>();
        TerrainData terrainData = terrainComponent.terrainData;

        // While the spaceship is null, try look for a candidate spot
        while (finalSpaceship == null) {
            // Initialises a randomized vector around the center
            Vector3 offsetVector = new Vector3(Random.Range(minDistance, maxDistance), 0.0f, 0.0f);
            offsetVector = Quaternion.Euler(0.0f, Random.Range(0.0f, 360.0f), 0.0f) * offsetVector;

            // Does a few checks on the position to ensure that it isn't too close to a river or
            // on a steep cliff
            float spaceshipRiverDistance = river.DistanceToTree(offsetVector + terrainData.bounds.center);

            if (spaceshipRiverDistance > riverDistance && spaceshipRiverDistance < maxRiverDistance) {
                // Attempts to create a spaceship
                GameObject candidateSpaceship = InstantiateGameobject(
                    spaceship, offsetVector + terrainData.bounds.center,
                    false, false, false
                );

                if (candidateSpaceship != null) {
                    finalSpaceship = candidateSpaceship;
                }
            }
        }

        return finalSpaceship;
    }

    // Moves the player to a place around the spaceship
    void MovePlayerAroundSpaceship(ref GameObject spaceship, float riverDistance, float distance) {
        // Sets a final position + boolean to check if it's set
        Vector3 finalPosition = new Vector3(0.0f, 0.0f, 0.0f);
        bool positionSet = false;

        while (!positionSet) {
            // Initialises a randomized vector around the spaceship
            Vector3 offsetVector = new Vector3(distance, 0.0f, 0.0f);
            offsetVector = Quaternion.Euler(0.0f, Random.Range(0.0f, 360.0f), 0.0f) * offsetVector;

            // Checks the distance from the river
            if (river.DistanceToTree(offsetVector + spaceship.transform.position) > riverDistance) {
                // Create a ray down to the terrain
                Ray positionalRay = new Ray(
                    offsetVector + spaceship.transform.position + new Vector3(0.0f, 100.0f, 0.0f),
                    new Vector3(0.0f, -1.0f, 0.0f)
                );
                RaycastHit hitInfo;

                // Check if the ray hit anything. If it did, then set that position
                if (Physics.Raycast(positionalRay, out hitInfo, 150.0f)) {
                    finalPosition = hitInfo.point + new Vector3(0.0f, 1.0f, 0.0f);
                    positionSet = true;
                }
            }
        }

        player.transform.position = finalPosition;
    }
    
    //---------------------------

    // Displaces the vertices based on the distance to an LTree
    IEnumerator DisplaceLTree(LTree tree, float maxDistance, float displacement, float dryStart, float dryEnd) {
        // Gets the terrain component + terrainData
        Terrain terrainComponent = terrain.GetComponent<Terrain>();
        TerrainData terrainData = terrainComponent.terrainData;

        // Gets the bounds of the LTree
        Bounds treeBounds = tree.GetTreeBounds();

        // Encapsulates new minimums and maximums that take into account the maxDistance
        treeBounds.Encapsulate(treeBounds.min + new Vector3(-maxDistance, 0.0f, -maxDistance));
        treeBounds.Encapsulate(treeBounds.max + new Vector3(maxDistance, 0.0f, maxDistance));

        // Get the terrain height + width
        int terrainHeight = terrainData.heightmapTexture.height - 1;
        int terrainWidth = terrainData.heightmapTexture.width - 1;

        // Get the minimum bound of the terrain and the resolution of each sample
        Vector3 terrainMinimum = terrainData.bounds.min;
        Vector3 sampleResolution = terrainData.heightmapScale;

        // From the bounds of the tree, we can determine what relevant samples to get
        (int, int) min = (
            (int) Mathf.Clamp((treeBounds.min.x - terrainMinimum.x) / sampleResolution.x, 0, terrainWidth),
            (int) Mathf.Clamp((treeBounds.min.z - terrainMinimum.z) / sampleResolution.z, 0, terrainHeight)
        );

        (int, int) max = (
            (int) Mathf.Clamp((treeBounds.max.x - terrainMinimum.x) / sampleResolution.x, 0, terrainWidth),
            (int) Mathf.Clamp((treeBounds.max.z - terrainMinimum.z) / sampleResolution.z, 0, terrainHeight)
        );

        // Gets the width and height of the map
        int width = max.Item1 - min.Item1;
        int height = max.Item2 - min.Item2;

        // Gets the heights for the terrain based on the tree bounds
        float[,] heights = terrainData.GetHeights(min.Item1, min.Item2, max.Item1 - min.Item1, max.Item2 - min.Item2);
        float[,,] alphaMaps = terrainData.GetAlphamaps(min.Item1, min.Item2, max.Item1 - min.Item1, max.Item2 - min.Item2);
        int[,] detailMap = terrainData.GetDetailLayer(min.Item1, min.Item2, max.Item1 - min.Item1, max.Item2 - min.Item2, 0);

        // Gets the y value of the tree's center
        float treeY = tree.GetTreeBounds().center.y;
        
        // Calculates the difference between the dry start and end
        float dryDiff = dryEnd - dryStart;

        // Fills the heightmap and detail map
        // Loop over the heights in the X and Y
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                // Get the height at this location
                float currHeight = heights[y, x];
                
                // Gets the position of the tile
                Vector3 tilePos = terrainMinimum + new Vector3(x * sampleResolution.x, treeY, y * sampleResolution.z);
                
                // Gets a list of distances close to the tree.
                List<float> treeDistances = tree.GetTreeDistanceList(tilePos, maxDistance);

                // Based on these distances, we see if the point is near any points
                if (treeDistances.Count > 0) {
                    // Loop over the tree distances to calculate the total displacement
                    float totalDisplacement = 0.0f;

                    foreach (float treeDistance in treeDistances) {
                        // Based on the max distance, calculate how far down the displacement should happen
                        float displacementBase = Mathf.Clamp(maxDistance - treeDistance, 0.0f, maxDistance);
                        float displacementHeight = -(Mathf.Cos(Mathf.PI * (displacementBase/maxDistance)) - 1.0f) / 2.0f;

                        // Add to the total displacement
                        totalDisplacement += displacementHeight;
                    }

                    // Clamps the total displacement
                    totalDisplacement = Mathf.Clamp(totalDisplacement, 0.0f, 1.0f);

                    // Set the new height
                    heights[y, x] = Mathf.Max(currHeight + -currHeight * totalDisplacement * 1.2f, 0.005f);

                    // Sets the alpha map based on the displacement
                    alphaMaps[y, x, 0] = 1 - totalDisplacement;
                    alphaMaps[y, x, 1] = totalDisplacement;
                    
                    detailMap[y, x] = (totalDisplacement > 0.3) ? 0 : fullGrassPatchCapacity;
                }
            }

            yield return null;
        }

        // Sets the heights in this range
        terrainData.SetHeights(min.Item1, min.Item2, heights);
        terrainData.SetAlphamaps(min.Item1, min.Item2, alphaMaps);
        terrainData.SetDetailLayer(min.Item1, min.Item2, 0, detailMap);

        // Sets the new terrain data
        terrainComponent.terrainData = terrainData;
        terrainComponent.Flush();

        yield return null;
    }
    
    //---------------------------

    // Adds pickup value based on the gameobject used
    void AddPickupValue(GameObject item) {
        // Gets the pickups inside the GameObject
        Pickup[] pickups = item.GetComponentsInChildren<Pickup>();

        // For each, add to the total
        foreach (Pickup pickup in pickups) {
            totalCredits += pickup.pickupValue;
        }
    }

    // Generates a certain number of campfire props nearby an LTree river,
    // but not too nearby
    List<GameObject> GenerateItems(
        string[] items, uint numItems, uint minDistance,
        uint maxDistance, bool removeGrass,
        bool rotateToTerrain, bool generateAtEdges,
        bool flattenTerrain
    ) {
        // Inits the array of GameObjects
        List<GameObject> objectList = new List<GameObject>();

        // Gets the terrain component + terrainData
        Terrain terrainComponent = terrain.GetComponent<Terrain>();
        TerrainData terrainData = terrainComponent.terrainData;

        // Get the minimum bound of the terrain and the resolution of each sample
        Vector3 terrainMinimum = terrainData.bounds.min;
        Vector3 sampleResolution = terrainData.heightmapScale;

        // Initialises a count for the number of items
        uint itemCount = 0;

        // Initialises the number of iterations
        uint numIterations = 0;
        
        // While the number of items hasn't been satisfied, generate.
        while (itemCount < numItems) {
            // First, we want to get the bounds of the river
            Bounds riverBounds = river.GetTreeBounds();

            // From the river bounds, we can begin to generate a random "placement" for
            // the item that we want to create.
            Vector3 queriedPosition = riverBounds.center + new Vector3(
                Random.Range(-riverBounds.extents.x, riverBounds.extents.x),
                0.0f,
                Random.Range(-riverBounds.extents.z, riverBounds.extents.z)
            );

            // Check the distance from the position to the river
            float riverDist = river.DistanceToTree(queriedPosition);

            // If the queried position is at where we want, we can add that item
            if (riverDist >= minDistance && riverDist <= maxDistance && (generateAtEdges || !IsNearEdge(queriedPosition))) {
                // Gets a random prefab
                int randomItemPrefab = Random.Range(0, items.Length);
                string itemPrefab = items[randomItemPrefab];
                
                // Attemps to create an item
                GameObject item = InstantiateGameobject(itemPrefab, queriedPosition, rotateToTerrain, removeGrass, flattenTerrain);

                // If the item creation was successful, we add to the gameobjects list
                if (item != null) {
                    // Adds the prefab to the gameobject list
                    objectList.Add(item);

                    itemCount++;
                    numIterations = 0;
                }
            }

            numIterations++;

            // If the number of iterations exceed 5000, flush and return the object list
            if (numIterations > 5000) {
                terrainComponent.Flush();
                return objectList;
            }
        }

        // Flush the terrain so that the details change
        terrainComponent.Flush();

        return objectList;
    }

    List<GameObject> GenerateItemsRadius(
        string[] items, ref List<GameObject> referenceItems, 
        uint numItems, float minDistance, float maxDistance,
        float riverDistance, bool removeGrass, bool rotateToTerrain,
        bool generateAtEdges, bool flattenTerrain
    ) {
        // Inits the array of GameObjects
        List<GameObject> objectList = new List<GameObject>();

        // Gets the terrain component + terrainData
        Terrain terrainComponent = terrain.GetComponent<Terrain>();

        // Initialises an item count
        uint itemCount = 0;

        // Initialises the number of iterations
        uint numIterations = 0;

        // While the item count is under the number of items specified
        // by the function, generate
        while (itemCount < numItems) {
            // Get a random object in the list of reference items
            GameObject refObject = referenceItems[Random.Range(
                0, referenceItems.Count - 1
            )];

            // Inits the largest extant for the ref object
            Bounds bounds = GetObjectBounds(refObject);

            // Initialises a randomized vector around the refObject
            Vector3 offsetVector = new Vector3(
                Mathf.Max(bounds.extents.x, bounds.extents.z) + Random.Range(minDistance, maxDistance),
                0.0f, 0.0f
            );

            offsetVector = Quaternion.Euler(0.0f, Random.Range(0.0f, 360.0f), 0.0f) * offsetVector;

            // We want to check if the offsetVector + the refObject position is away from the river
            Vector3 queriedPosition = refObject.transform.position + offsetVector;

            if (river.DistanceToTree(queriedPosition) > riverDistance && (generateAtEdges || !IsNearEdge(queriedPosition))) {
                // Gets a random prefab
                int randomItemPrefab = Random.Range(0, items.Length);
                string itemPrefab = items[randomItemPrefab];
                
                // Attemps to create an item
                GameObject item = InstantiateGameobject(itemPrefab, queriedPosition, rotateToTerrain, removeGrass, flattenTerrain);

                // If the item creation was successful, we add to the gameobjects list
                if (item != null) {
                    // Adds the prefab to the gameobject list
                    objectList.Add(item);

                    itemCount++;
                    numIterations = 0;
                }
            }

            numIterations++;

            // If the number of iterations exceed 5000, flush and return the object list
            if (numIterations > 5000) {
                terrainComponent.Flush();
                return objectList;
            }
        }

        // Flush the terrain so that the details change
        terrainComponent.Flush();

        // Returns the game objects
        return objectList;
    }

    List<GameObject> GenerateEdgeItems(
        string[] items, uint numItems, bool removeGrass,
        bool rotateToTerrain, bool flattenTerrain
    ) {
        // Inits the array of GameObjects
        List<GameObject> objectList = new List<GameObject>();

        // Gets the terrain component + terrainData
        Terrain terrainComponent = terrain.GetComponent<Terrain>();
        TerrainData terrainData = terrainComponent.terrainData;

        // Get the terrain bound minimum and maximum
        Vector3 terrainMinimum = terrainData.bounds.min;
        Vector3 terrainMaximum = terrainData.bounds.max;
        
        int heightmapWidth = terrainData.heightmapTexture.width;
        int heightmapHeight = terrainData.heightmapTexture.height;

        Vector3 sampleResolution = terrainData.heightmapScale;

        // Initialises a count for the number of items
        uint itemCount = 0;
        
        // Initialises the number of iterations
        uint numIterations = 0;

        // While the number of items hasn't been satisfied, generate.
        while (itemCount < numItems) {
            // Randomised the major axis for the edge
            int axisSelection = Random.Range(0, 2);

            // Randomises the Vector3 based on the axis selection
            // Direct generation on the edges isn't ideal since it might be
            // causing things to generate in the air, this should solve that issue(?)
            Vector3 queriedPosition = (axisSelection == 1) ? (
                new Vector3(
                    Random.Range(terrainMinimum.x, terrainMaximum.x),
                    0.0f,
                    ((edgeFalloff / 2 + Random.Range(0, 2)
                        * (heightmapHeight - edgeFalloff))
                        + Random.Range(-edgeFalloff / 2.5f, edgeFalloff / 2.5f)
                    ) * sampleResolution.z
                )
            ) : (
                new Vector3(
                    ((edgeFalloff / 2 + Random.Range(0, 2)
                        * (heightmapWidth - edgeFalloff))
                        + Random.Range(-edgeFalloff / 2.5f, edgeFalloff / 2.5f)
                    ) * sampleResolution.x,
                    0.0f,
                    Random.Range(terrainMinimum.z, terrainMaximum.z)
                )
            );

            // Gets a random prefab
            int randomItemPrefab = Random.Range(0, items.Length);
            string itemPrefab = items[randomItemPrefab];
            
            // Attemps to create an item
            GameObject item = InstantiateGameobject(
                itemPrefab, queriedPosition, rotateToTerrain, removeGrass, flattenTerrain
            );

            // If the item creation was successful, we add to the gameobjects list
            if (item != null) {
                // Adds the prefab to the gameobject list
                objectList.Add(item);

                itemCount++;
                numIterations = 0;
            }

            numIterations++;

            // If the number of iterations exceed 5000, flush and return the object list
            if (numIterations > 5000) {
                terrainComponent.Flush();
                return objectList;
            }
        }

        // Flush the terrain so that the details change
        terrainComponent.Flush();

        return objectList;
    }
    
    //---------------------------

    // Clears out the grass from a particular area
    void ClearGrass(GameObject item) {
        // Creates bounds from the item
        Bounds grassBounds = GetObjectBounds(item);

        // Gets the terrain component + terrainData
        Terrain terrainComponent = terrain.GetComponent<Terrain>();
        TerrainData terrainData = terrainComponent.terrainData;

        // Get the min bound of the terrain, dimensions and the resolution of each sample
        Vector3 terrainMinimum = terrainData.bounds.min;
        Vector3 sampleResolution = terrainData.heightmapScale;

        // Gets the size of the heightmap texture
        float heightmapHeight = terrainData.heightmapTexture.height;
        float heightmapWidth = terrainData.heightmapTexture.width;

        // Gets the min and max bounds of the item converted into x and z values
        int originX = (int) Mathf.Floor((
            grassBounds.min.x - terrainMinimum.x
        ) / sampleResolution.x) - 1;
        int originY = (int) Mathf.Floor((
            grassBounds.min.z - terrainMinimum.z
        ) / sampleResolution.z) - 2;
        
        int sizeX = (int) Mathf.Floor((
            grassBounds.max.x - terrainMinimum.x
        ) / sampleResolution.x) + 2;
        int sizeY = (int) Mathf.Floor((
            grassBounds.max.z - terrainMinimum.z
        ) / sampleResolution.z);

        // Performs clamping on the origin and size variables, mods the size variables by the origin
        originX = Mathf.Clamp(originX, 0, (int) heightmapWidth);
        originY = Mathf.Clamp(originY, 0, (int) heightmapHeight);

        sizeX = Mathf.Clamp(sizeX, 0, (int) heightmapWidth) - originX;
        sizeY = Mathf.Clamp(sizeY, 0, (int) heightmapHeight) - originY;

        // Calculate the center, so that we know how far the point is from the detailMap
        int centerX = originX + sizeX / 2;
        int centerY = originY + sizeY / 2;

        // If the sizes fit, proceed
        if (sizeX > 0 && sizeY > 0) {
            // Based on the size, gets a grass patch, loops over and replaces it
            int[,] detailMap = terrainData.GetDetailLayer(originX, originY, sizeX, sizeY, 0);

            // Gets the maximum distance from the center to the edge
            float maxDist = Mathf.Pow(sizeX / 2, 2.0f) + Mathf.Pow(sizeY / 2, 2.0f);

            for (int x = 0; x < sizeX; x++) {
                for (int y = 0; y < sizeY; y++) {
                    // Gets the distance from the center
                    float centerDist = Mathf.Pow(x - sizeX / 2, 2.0f) + Mathf.Pow(y - sizeY / 2, 2.0f);

                    // Calculates the final density
                    if (detailMap[y, x] != 0) {
                        detailMap[y, x] = (int) (detailMap[y, x] * Mathf.Pow(centerDist / maxDist, 2));
                    }
                }
            }

            // Sets the detailMap
            terrainData.SetDetailLayer(originX, originY, 0, detailMap);
        }
    }

    // Dries up grass in a particular area, also re-colours the ground here too
    void DryGrass(GameObject item) {
        // Creates bounds from the item
        Bounds grassBounds = GetObjectBounds(item);

        // We want to double the size of the grass bounds prior, since we want this to cover a large area
        grassBounds.size = grassBounds.size * 5.0f;

        // Gets the terrain component + terrainData
        Terrain terrainComponent = terrain.GetComponent<Terrain>();
        TerrainData terrainData = terrainComponent.terrainData;

        // Get the min bound of the terrain, dimensions and the resolution of each sample
        Vector3 terrainMinimum = terrainData.bounds.min;
        Vector3 sampleResolution = terrainData.heightmapScale;

        // Gets the size of the heightmap texture
        float heightmapHeight = terrainData.heightmapTexture.height;
        float heightmapWidth = terrainData.heightmapTexture.width;

        // Gets the min and max bounds of the item converted into x and z values
        int originX = (int) Mathf.Floor((
            grassBounds.min.x - terrainMinimum.x
        ) / sampleResolution.x) - 1;
        int originY = (int) Mathf.Floor((
            grassBounds.min.z - terrainMinimum.z
        ) / sampleResolution.z) - 2;
        
        int sizeX = (int) Mathf.Floor((
            grassBounds.max.x - terrainMinimum.x
        ) / sampleResolution.x) + 2;
        int sizeY = (int) Mathf.Floor((
            grassBounds.max.z - terrainMinimum.z
        ) / sampleResolution.z);

        // Performs clamping on the origin and size variables, mods the size variables by the origin
        originX = Mathf.Clamp(originX, 0, (int) heightmapWidth);
        originY = Mathf.Clamp(originY, 0, (int) heightmapHeight);

        sizeX = Mathf.Clamp(sizeX, 0, (int) heightmapWidth) - originX - 1;
        sizeY = Mathf.Clamp(sizeY, 0, (int) heightmapHeight) - originY - 1;

        // Calculate the center, so that we know how far the point is from the detailMap
        int centerX = originX + sizeX / 2;
        int centerY = originY + sizeY / 2;

        // If the sizes fit, proceed
        if (sizeX > 0 && sizeY > 0) {
            // Based on the size, gets patches of healthy grass and replaces them with dry
            int[,] healthyDetailMap = terrainData.GetDetailLayer(originX, originY, sizeX, sizeY, 0);
            int[,] dryDetailMap = terrainData.GetDetailLayer(originX, originY, sizeX, sizeY, 1);

            // Gets the alpha maps for this region of ground
            float[,,] alphaMap = terrainData.GetAlphamaps(originX, originY, sizeX, sizeY);

            // Gets the maximum distance from the center to the edge
            float maxDist = Mathf.Min(Mathf.Pow(sizeX / 2, 2.0f), Mathf.Pow(sizeY / 2, 2.0f));

            for (int x = 0; x < sizeX; x++) {
                for (int y = 0; y < sizeY; y++) {
                    // Gets the distance from the center
                    float centerDist = Mathf.Pow(x - sizeX / 2, 2.0f) + Mathf.Pow(y - sizeY / 2, 2.0f);

                    // Calculates the falloff for the dry and healthy grass
                    float grassFalloff = Mathf.Pow(Mathf.Clamp(centerDist / maxDist, 0.0f, 1.0f), 1.5f);

                    // Calculates the final density
                    int initialGrassDensity = healthyDetailMap[y, x];

                    // Sets the values for the detail map on the ground
                    healthyDetailMap[y, x] = (int) (initialGrassDensity * grassFalloff);
                    dryDetailMap[y, x] = dryDetailMap[y, x] + (int) (initialGrassDensity * (1.0f - grassFalloff));

                    // Sets the values of the alpha maps
                    alphaMap[y, x, 0] = alphaMap[y, x, 0] * grassFalloff;
                    alphaMap[y, x, 1] = alphaMap[y, x, 1] * grassFalloff;
                    alphaMap[y, x, 3] = Mathf.Clamp(alphaMap[y, x, 3] + (1.0f - grassFalloff), 0.0f, 1.0f);
                }
            }

            // Sets the detailMap
            terrainData.SetDetailLayer(originX, originY, 0, healthyDetailMap);
            terrainData.SetDetailLayer(originX, originY, 1, dryDetailMap);
        
            // Sets the alpha maps
            terrainData.SetAlphamaps(originX, originY, alphaMap);
        }
    }

    // Flattens terrain in a particular area
    void FlattenTerrain(GameObject item, float flattenHeight) {
        // Creates bounds from the item
        Bounds itemBounds = GetObjectBounds(item);

        // Gets the terrain component + terrainData
        Terrain terrainComponent = terrain.GetComponent<Terrain>();
        TerrainData terrainData = terrainComponent.terrainData;

        // Get the min bound of the terrain, dimensions and the resolution of each sample
        Vector3 terrainMinimum = terrainData.bounds.min;
        Vector3 sampleResolution = terrainData.heightmapScale;

        // Gets the size of the heightmap texture
        float heightmapHeight = terrainData.heightmapTexture.height;
        float heightmapWidth = terrainData.heightmapTexture.width;

        // Gets the min and max bounds of the item converted into x and z values
        int originX = (int) Mathf.Floor((
            itemBounds.min.x - terrainMinimum.x
        ) / sampleResolution.x) - 1;
        int originY = (int) Mathf.Floor((
            itemBounds.min.z - terrainMinimum.z
        ) / sampleResolution.z) - 2;
        
        int sizeX = (int) Mathf.Floor((
            itemBounds.max.x - terrainMinimum.x
        ) / sampleResolution.x) + 2;
        int sizeY = (int) Mathf.Floor((
            itemBounds.max.z - terrainMinimum.z
        ) / sampleResolution.z);

        // Performs clamping on the origin and size variables, mods the size variables by the origin
        originX = Mathf.Clamp(originX, 0, (int) heightmapWidth);
        originY = Mathf.Clamp(originY, 0, (int) heightmapHeight);

        sizeX = Mathf.Clamp(sizeX, 0, (int) heightmapWidth) - originX;
        sizeY = Mathf.Clamp(sizeY, 0, (int) heightmapHeight) - originY;

        // Calculate the center, so that we know how far the point is from the detailMap
        int centerX = originX + sizeX / 2;
        int centerY = originY + sizeY / 2;

        // If the sizes fit, proceed
        if (sizeX > 0 && sizeY > 0) {
            // Based on the size, gets a grass patch, loops over and replaces it
            float[,] heightMap = terrainData.GetHeights(originX, originY, sizeX, sizeY);

            // Gets the maximum distance from the center to the edge
            float maxDist = Mathf.Pow(sizeX / 2, 2.0f) + Mathf.Pow(sizeY / 2, 2.0f);

            for (int x = 0; x < sizeX; x++) {
                for (int y = 0; y < sizeY; y++) {
                    // Gets the distance from the center
                    float centerDist = Mathf.Pow(x - sizeX / 2, 2.0f) + Mathf.Pow(y - sizeY / 2, 2.0f);

                    // Gets the "flattening amount" based on the center and max dist
                    float flattenAmount = 1.0f - Mathf.Pow(centerDist / maxDist, 3.0f);

                    heightMap[y, x] = heightMap[y, x] + (
                        (flattenHeight - terrainPosition.y) / terrainDimensions.y - heightMap[y, x]
                    ) * flattenAmount;
                }
            }

            // Sets the heightMap
            terrainData.SetHeights(originX, originY, heightMap);
        }
    }

    //----------------------------

    // Calculates the position that a point lies on the terrain grid
    (int, int) CalculateGridPosition(Vector3 pos, Bounds terrainBounds, Vector3 sampleResolution) {
        return (
            (int) ((pos.x - terrainBounds.min.x) / sampleResolution.x),
            (int) ((pos.z - terrainBounds.min.z) / sampleResolution.z)
        );
    }

    bool IsNearEdge(Vector3 pos) {
        // Gets the data for the terrain
        TerrainData terrainData = terrain.GetComponent<Terrain>().terrainData;

        // Gets the terrain bounds, size of the heightmap + resolution
        Bounds terrainBounds = terrainData.bounds;
        Vector3 sampleResolution = terrainData.heightmapScale;

        int heightmapWidth = terrainData.heightmapTexture.width;
        int heightmapHeight = terrainData.heightmapTexture.height;

        // Now, we check if the pos is within the bounds
        (int, int) bounds = CalculateGridPosition(pos, terrainBounds, sampleResolution);

        return (
            bounds.Item1 <= edgeFalloff ||
            bounds.Item1 >= heightmapWidth - edgeFalloff ||
            bounds.Item2 <= edgeFalloff ||
            bounds.Item2 >= heightmapHeight - edgeFalloff
        );
    }

    //----------------------------

    public bool GetTerrainLoaded() {
        return terrainLoaded;
    }

    public Vector3 GetCenter() {
        // Get the terrainData from the terrain
        TerrainData terrainData = terrain.GetComponent<Terrain>().terrainData;

        return terrainData.bounds.center;
    }
    
    //----------------------------

    public GameObject GetStartingOxygen() {
        return startingOxygenObject;
    }

    public List<GameObject> GetCampsiteOxygen() {
        return campOxygenStations;
    }
}